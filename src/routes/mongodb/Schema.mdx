---
title: Mongoose
---

## schema
To create Database we define how the sturcture of our data looks  
example we want have users in our db : 

```
{
    username : "alex" ,
    email : "example@gmail.com",
    password : "password123",
}
```
This is how we want our user data to look like , mongodb call sturcture `schema` and each data of the structure `model` so in that sence the above object is called `model` of our User Schema
and to so to create these entries of our user , we need to `define our schemas` first
also to note as we know mongodb store data in form of json like format

## Creating Schema
To create schema we first import the mongoose module and call .schema method on it 
also .schema is a constructure method so need to use "new" keyword before it
```js
import {mongoose} from "./index.ts"

const UserSchema = new mongoose.schema({
    // Field get defined here
}, {
    // optional schema's extra option go here
})
```
This is the syntax of schema creation , let's create define each fields of our data

```js
 new mongoose.schema({
    username : {
      type : String,    // username data will be string
      required : true  // required is true
    },
  // extra fields
},)
```
So let's first see what we can defind in a single field

 ## Field options
```js
fieldName: {
  type: String,           // â† REQUIRED
  required: boolean | [boolean, 'Error message'],
  default: any | Function,
  unique: boolean,
  index: boolean,         // single-field index
  sparse: boolean,        // creates unique index
  trim: boolean,          // for strings
  lowercase: boolean,     // for strings
  uppercase: boolean,     // for strings
  minlength: number | [number, 'Error msg'],
  maxlength: number | [number, 'Error msg'],
  min: number,              // for numbers data type
  max: number,              // for numbers data type
  match: RegExp,            // for validating strings data type
  enum: string[] | object,  // for strings/numbers
  validate: Function | {
    validator: Function,
    message: string
  }
}
```


 ## Demonstrate of field options

1. String validation
 ```js
 username: {
  type: String,
  required: [true, 'Username is required'],
  minlength: [2, 'Min 2 chars'],
  maxlength: [30, 'Max 30 chars'],
  trim: true,
  lowercase: true,
  unique: true
}

 ```





2. You can also do short hand entries like
 ```js
 email: String,
 numbers : [Number],
 isReal : boolean

 ```
 Instead of defining each entries , not recommended ofc but who cares 


2. Email with regex
 ```js
 email: {
  type: String,
  required: true,
  match: [/^\S+@\S+\.\S+$/, 'Invalid email']
}

 ```
3. Number with range
 ```js

 age: {
  type: Number,
  min: [0, 'Age must be positive'],
  max: [120, 'Too old!']
}

 ```
 4. Enum (e.g. options have to choose from these options only)

 ```js
 role: {
  type: String,
  enum: ['user', 'admin', 'mod'],
  default: 'user'
}

 ```

 5. Date with default

 ```js
createdAt: {
  type: Date,
  default: Date.now
}
 ```

 6. ObjectId (Reference to another model)

 ```js
 author: {
  type: Schema.Types.ObjectId,  // mongodb's Id data type 
  ref: 'User',        // model name to populate from
  required: true
}

 ```
 
 

7.  Array of primitives and validate function

 ```js
tags: [String], // shorthand
// or
hobbies: {
  type: [{ type: String }],
  validate: arr => arr.length <= 5
}

 ```

 
 7. Array Field ( by wrapping the object by array)

 ```js
friends: [{
  type: String,
}]

 ```
 

8. Nested subdocument (object)

 ```js
address: {
  street: String,
  city: String,
  country: {
    type: String,
    required: true
  }
}
 ```
 

# SChema Options

 ```js
const userSchema = new Schema({ ... }, {
  timestamps: true,           // adds createdAt, updatedAt field at data entry
  // Come here after you learn model and methods
  toJSON: { virtuals: true }, // include virtuals in JSON
  toObject: { virtuals: true },
  id: false,                  // disable auto _id â†’ virtual id
  versionKey: false,          // Removes __v (optimistic locking field) â€” safe to disable if you donâ€™t use save() with concurrent updates
  collection: 'users_custom'  // custom collection name (all models stores inside a collection default is model name)
});
 ```





## Virtuals : true
virtuals are function you can define in the schema and you can use them to get a computed value of the data 
exmple : 
```js
userSchema.virtual('fullName').get(function () {
  return `${this.firstName} ${this.lastName}`;
});

```
now when you do 
```js
const user = await User.findOne(); // method to find data
console.log(user.fullName); // "Alice Smith" â†’ computed!

```
but it only stays in backend , it doesn't get converted into json if you try to do
example : 
```js
res.json(user); 
// âŒ Output: { firstName: "Alice", lastName: "Smith" } â†’ NO fullName!
```
Cause they are hidden by default
to make them appear do 
```js
  toJSON: { virtuals: true }, // for json 
```
```js
  toObject: { virtuals: true }, // for .toObject() , who uses toObject now days? tf?matybe u need it?
```


# Schema methods 
 

| difference       | meaning        |       define via  |    access via    |
| -------- | :------- | -------: | :------: |
| virtual | Computed  | properties (like fullName) | ```user.fullName``` |
| Methods    | Custom   |    functions on documents  | ```schema.methods.generateToken = function() {...}``` | user.generateToken()  |

















# _V field
Time 1: You load the account
```js
const acc1 = await Account.findById(id); // balance=100, __v=0
```
Time 2: Friend loads the same account
```js
const acc2 = await Account.findById(id); // balance=100, __v=0
```
Time 3: Friend deposits $50
```js
acc2.balance += 50; // 150
await acc2.save(); 
// DB now: { balance: 150, __v: 1 }
```
Time 4: You withdraw $30 (but you still think balance is 100!)
```js
acc1.balance -= 30; // 70 â† based on stale data!
await acc1.save();
âŒ Without __v:
Your save overwrites the friendâ€™s deposit
Final balance = $70 (should be $120)
$50 is lost forever! ðŸ’¥
âœ… With __v:
When you call acc1.save(), Mongoose checks:
```

â€œIs the current __v in DB still 0 (what I loaded)?â€
But DB now has __v: 1 â†’ mismatch!
Mongoose throws an error: VersionError
You catch the error and retry safely

`Although this is useless if you use .findoneandUpdateMethod()` cause findoneandUpdateMethod don't rely on stall data , it always have updated data from db.
so again
.save() it saves the current modified data into db so it need that _v to identify if the specific data is already being updated after you fetched the data from db,
if the v isn't same it give error.. and from that error you can then retry to update with new fetch data and update it..




## pre and post Methods

```js
userSchema.pre('save', function (next) {
  // runs BEFORE saving
  next();
});

userSchema.post('save', function (doc, next) {
  // runs AFTER saving
  next();
});
```
## All the methods

| Event     | When It Runs        | 
| -------- | :------- | 
|'save' | Before/after .save() or .create() |
|'save' | During validation |
| 'remove'    | When deleting   |    
| 'findOneAndUpdate'    | Before/after findOneAndUpdate  |    
| 'insertMany'    | During bulk inserts  |    
