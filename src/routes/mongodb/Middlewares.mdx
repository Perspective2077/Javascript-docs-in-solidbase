---
title: Mongoose
---

# Middlewares
Middlewares in mongodb you can use for validating , modifying fetch or CRUD request and many more   
here can some middlewares you can use 

## Virtuals
Middleware function you can create and assign to specific field, that will be avaialbe in fetched data  
1. This middleware function will only be avaialbe when you convert your mongodb data into Either toJSON() or toObject()   
Example : 
```js
userSchema.virtual('text').get(function () {
  return `Hello User ${this.username}`;
});

user.text // "hello User Nigga"
```
You can use virtuals for calculating or need dynamic data info for ease to access without storing them in db

## Methods
Custom Utils you can create for Specific Scehma's instances ( aka object data)
```js
userSchema.methods.bycrptPassword = function () {
  return bycrpt(this.password)  // give encrpyted password
};
 
const user = await User.findById(id);
user.bycrptPassword() 
```
This way you can do type of functionality you want , better sturcture ig? 

## Statics
Same as methods but instead of attaching to instances it attaches to the schemas itself..  
example : 
```js
userSchema.statics.findByUsername = async function (username) {
  return this.findOne({ username: new RegExp(`^${username}$`, 'i') });
};

const user = await User.findByUsername('Alice');
```

So any you can see you can create multiple utils by this instead of creating dedicated function.. well you need to know what you are doing right. not every shiny thing need to be used

# Middleware  ( pre and post)
Run code before or after crud Operations of mongodb  
example : 
```js
// Before save
userSchema.pre('save', async function () {
  if (this.isModified('password')) {
    this.password = await hash(this.password);
  }
});

// After save
userSchema.post('save', function (doc) {
  console.log(`${doc.username} was saved!`);
});
```
So these function you can attach to each operation of mongodb like 
`save(),create(),findOne(),findoneandUpdate(),remove(),validate()`

[mongoDb methods](http://localhost:4000/mongodb/methods)

So what you can do in `pre` middleware is modify the query object inside the function and mongodb update the object in db itself..   
and you can use `post` middleware for logging or response etc etc 
Also you can access methods inside pre post methods as follows :  
## For query object methods 
```js
this.getUpdate() // given object to the method
this.getFilter() // given object use give to the method
```
Example :
```js
Model.findOneAndUpdate(
  { _id: id },                     // â† filter
  { $set: { name: "Alice" } }     // â† this is the "update object"
);

const update = this.getUpdate();
// â†’ { $set: { name: "Alice" } }
const update = this.getFilter();
// â†’ { _id: id }
```


## for Document type methods i.e. `.save() or .create()`

```js
this.fieldName // get fieldvalue
this.isModified() // Checks if field changed since last load or creation (it do by fetching new object and your last loaded data)
```

[All query options you can get in .getUpdate() method](http://localhost:4000/mongodb/queryObject)




## example OF pre : 
```js
userSchema.pre('findOneAndUpdate', async function () {
  const update = this.getUpdate(); // â† points to { $set: { password: "plainText" } }
  
  // You modify the object in place:
  update.$set.password = await hash("plainText");  // modify the original query object you gave
  // sucsexfully updated the query object
});

// Your code
await User.findOneAndUpdate(
  { email: "alice@example.com" },
  { $set: { password: "newPassword123" } }
);
// â†’ Password is hashed before DB update!
```


 # Transform
 An additional function you can pass to toJSON and toObject Field for addition functionality , that gonna run whenever you call .toJSON or .toObject   
 Note that transform is like for whole object and virtuals is like multiple methods inside the method you can create   
 props transform function get : 
 ```js
 transform: (doc, ret , options) => {
      console.log(doc)  // The original Mongoose document (with methods, virtuals, etc.) aka raw moongoose object
      console.log(ret)  // The plain JSON object that will be returned (mutable!)
      console.log(options) // Options passed to .toJSON() or .toObject() 
    }   
 ```   
 Example of Transform : 
 ```js
 const userSchema = new Schema({
  password: String,
  email: String
}, {
  // ðŸ‘‡ Schema-level option
  toJSON: {
    transform: (doc, ret) => {
      // Modify 'ret' (the output object)
      delete ret.password;
      return ret;
    }
  },
  toObject: {
    transform: (doc, ret) => { /* same */ }
  }
});
 ```

