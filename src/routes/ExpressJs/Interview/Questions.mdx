---
title: FAQ
---


# {frontmatter.title}


## 1. What is Express Js
:::details[Answer]
Express.js is a fast, minimalist web framework for Node.js that provides a robust set of features for building web applications and APIs. It simplifies HTTP server creation, routing, middleware handling, and request/response processing—making it the most popular backend framework in the Node.js ecosystem.
::: 


## 2. What are middleware functions in Express? How do you use next()?
:::details[Answer]
Middleware functions in Express are functions that have access to the request object (req), the response object (res), and the next function in the application's request-response cycle.
What they do:

- Execute any code
- Modify the req or res objects
- End the request-response cycle (send a response)
- Call the next middleware function (using next())

How next() works:

- When you call next(), it passes control to the next middleware in the stack
- If you forget next(), the request will hang and never complete
- If you pass an error to next(error), it skips to the error-handling middleware

Types of middleware: 

- Application-level: app.use(), app.get()
- Router-level: router.use()
- Built-in: express.static() for serving files
- Error-handling: (err, req, res, next) => {}
- Third-party: cors, body-parser, etc.
:::


## 3. How do you handle routing in Express? What's the difference between app.get() and router.get()?
:::details[Answer]
Routing in Express is how you define what happens when users visit different URLs (endpoints) in your application. 
Using app.get() (Application-level routing): 
Defines routes directly on the main Express app
Good for simple applications
Example:
```
const express = require('express');
const app = express();

app.get('/', (req, res) => {
  res.send('Home page');
});

app.get('/users', (req, res) => {
  res.send('List of users');
});
```


Using router.get() (Router-level routing): 

Creates separate route modules using express.Router()
Better for organizing larger applications
Allows you to group related routes together
Example:
```
// routes/users.js
const express = require('express');
const router = express.Router();

router.get('/', (req, res) => {
  res.send('List of users');
});

router.get('/:id', (req, res) => {
  res.send(`User ${req.params.id}`);
});

module.exports = router;

// app.js
const userRoutes = require('./routes/users');
app.use('/api/users', userRoutes); // All user routes prefixed with /api/users
```
Key differences: 

app.get(): Routes are defined directly on the main app, good for small apps
router.get(): Routes are organized in separate files, better for large apps with many endpoints
Reusability: Router allows you to create modular, reusable route groups
Organization: Router helps keep your main app file clean and organized


:::

## 4. What is req.params, req.query, and req.body? How are they different?
:::details[Answer]
These are three different ways Express extracts data from incoming HTTP requests:    
req.params:
Contains URL route parameters (dynamic parts of the URL)
Used for path variables like `/users/:id`   
Example:

```
app.get('/users/:id', (req, res) => {
  console.log(req.params.id); // If URL is /users/123, req.params.id = "123"
});
```

req.query: 
Contains URL query parameters (the part after ? in the URL)
Used for optional, filterable data
Example:
```app.get('/search', (req, res) => {
  console.log(req.query.q);    // If URL is /search?q=javascript, req.query.q = "javascript"
  console.log(req.query.page); // If URL is /search?q=js&page=2, req.query.page = "2"
});
```

req.body: 
Contains data sent in the request body (like form submissions or JSON)
Requires middleware like express.json() or body-parser
Example:
```app.get('/search', (req, res) => {
  console.log(req.query.q);    // If URL is /search?q=javascript, req.query.q = "javascript"
  console.log(req.query.page); // If URL is /search?q=js&page=2, req.query.page = "2"
});
```


Key differences: 
- req.params: For required URL segments (/users/123)
- req.query: For optional URL parameters (/search?q=term)
- req.body: For data sent in request body (POST, PUT requests)
:::

## 5. How do you handle errors in Express? What is an error-handling middleware?
:::details[Answer]
A compiled language is one where the source code is translated into machine code (or low-level binary) by a compiler before it’s executed. This creates an executable file that then can run directly on the computer’s hardware. Examples most languages include C, C++, and Rust.  
Because the code is pre-compiled, compiled languages typically offer faster performance and early error detection during the build step.
:::


## 5. What are RESTful APIs? How do you implement them with Express?
:::details[Answer]
A compiled language is one where the source code is translated into machine code (or low-level binary) by a compiler before it’s executed. This creates an executable file that then can run directly on the computer’s hardware. Examples most languages include C, C++, and Rust.  
Because the code is pre-compiled, compiled languages typically offer faster performance and early error detection during the build step.
:::

## 5. How do you serve static files (CSS, images, etc.) in Express?
:::details[Answer]
A compiled language is one where the source code is translated into machine code (or low-level binary) by a compiler before it’s executed. This creates an executable file that then can run directly on the computer’s hardware. Examples most languages include C, C++, and Rust.  
Because the code is pre-compiled, compiled languages typically offer faster performance and early error detection during the build step.
:::


## 5. What is CORS and how do you enable it in Express?
:::details[Answer]
A compiled language is one where the source code is translated into machine code (or low-level binary) by a compiler before it’s executed. This creates an executable file that then can run directly on the computer’s hardware. Examples most languages include C, C++, and Rust.  
Because the code is pre-compiled, compiled languages typically offer faster performance and early error detection during the build step.
:::

## 5. How do you connect Express to a database (e.g., MongoDB, PostgreSQL)?
:::details[Answer]
A compiled language is one where the source code is translated into machine code (or low-level binary) by a compiler before it’s executed. This creates an executable file that then can run directly on the computer’s hardware. Examples most languages include C, C++, and Rust.  
Because the code is pre-compiled, compiled languages typically offer faster performance and early error detection during the build step.
:::


## 5. What is Express generator and why is it useful?
:::details[Answer]
A compiled language is one where the source code is translated into machine code (or low-level binary) by a compiler before it’s executed. This creates an executable file that then can run directly on the computer’s hardware. Examples most languages include C, C++, and Rust.  
Because the code is pre-compiled, compiled languages typically offer faster performance and early error detection during the build step.
:::


## 5. How do you secure an Express app? (e.g., Helmet, rate limiting, input validation)
:::details[Answer]
A compiled language is one where the source code is translated into machine code (or low-level binary) by a compiler before it’s executed. This creates an executable file that then can run directly on the computer’s hardware. Examples most languages include C, C++, and Rust.  
Because the code is pre-compiled, compiled languages typically offer faster performance and early error detection during the build step.
:::

